# Index

## Index와 Table의 상호작용

쿼리를 실행할 때, 기본적으로 데이터베이스는 **전체 테이블 스캔(full table scan)을 수행**합니다.  
모든 행을 하나씩 확인하면서 조건을 만족하는지 검사하기 때문에 테이블이 클수록 속도가 느려집니다.

<br>

인덱스를 사용하면, 필요한 데이터만 바로 찾을 수 있지만 모든 조건이 인덱스에 포함된 것은 아니므로 **여전히 불필요한 데이터가 로드될 수 있기 때문에 조건이 걸린 컬럼을 적절히 인덱스에 포함하는 것이 중요**합니다.

<br>
<br>

## Index 접근 원칙

SQL 연산이 인덱스를 활용하는 방식을 설명하는 네 가지 원칙은 아래와 같습니다.

1. 빠른 조회 (Fast Lookup)
    - 인덱스의 가장 기본적인 기능은 저장된 값 중 특정 값을 빠르게 찾는 것입니다.  

2. 한 방향으로만 스캔 (Scan in One Direction)
    - 인덱스는 단순한 빠른 조회뿐만 아니라, 특정 위치에서 시작하여 정렬된 리스트를 한 방향으로 스캔하는 기능도 제공합니다.  
    - 오름차순과 내림차순을 동시에 스캔하는 것은 불가능합니다.  

3. 왼쪽에서 오른쪽으로 (From Left To Right)  
    - 왼쪽에서 오른쪽으로, 컬럼을 건너뛰지 않고 사용해야 합니다.  
    - 올바른 접근법은 **가장 많은 쿼리를 최적화할 수 있는 순서로 컬럼을 배치하는 것**입니다.  
    - 다중 열 인덱스를 사용할 때, 특정 컬럼을 건너뛰면 인덱스의 효율성이 감소합니다.  
    - 다중 열 인덱스를 사용하고 있다면 다중 열에 포함된 단일 열 인덱스는 불필요합니다.  

4. 범위 조건 스캔 (Scan on Range Conditions)
    - **범위 조건(<, <=, >=, >)** 을 사용할 때는 동작 방식이 다릅니다.
    - 다중 열 인덱스를 적용할 때 **범위 조건이 포함될 경우, 동등 조건을 만족하는 컬럼을 앞쪽에 배치하는 것이 좋습니다.**

<br>
<br>

## Index가 지원하는 연산

인덱스 접근 원칙을 활용하면 모든 쿼리에 대해 최적의 인덱스를 설계할 수 있습니다.  
하지만 단순한 `WHERE` 조건만 사용하는 것이 아니라 복잡한 쿼리도 고려해야 합니다.  

<br>

필터링과 정렬을 수행하는 쿼리라면, 필터링 컬럼이 정렬 컬럼보다 먼저 인덱스에 포함되어야 합니다.  

<br>

### 부등호(`!=`)

인덱스를 통해 특정 값을 찾는 것이 아니라 전체 인덱스를 순회하며 확인해야 하기 때문에 성능을 크게 저하시킵니다.  
데이터베이스는 해당 조건을 만족하는 레코드 개수를 미리 예측할 수 없기 때문에 전체 테이블을 스캔하는 방식으로 동작합니다.  

단순한 인덱스 추가만으로 성능을 개선할 수 없으며, 쿼리 자체를 최적화해야 합니다.  

- 해결책
  - **다른 컬럼 추가**
    - 부등호 조건과 함께 사용되는 다른 컬럼을 포함한 인덱스를 생성하면, 특정 범위 내에서 검색할 수 있습니다.

  - **부등호를 등호로 변환**
    - `!=` 조건을 `boolean` 값으로 변환하면, 단순한 `=` 비교로 인덱스를 활용할 수 있습니다.

<br>

### `NULL` 값 (`IS NULL` 및 `IS NOT NULL`)

`NULL`은 값이 존재하지 않음을 의미하는 특별한 경우입니다.  
따라서 `NULL = NULL` 또는 `NULL != NULL` 비교는 항상 `FALSE`가 됩니다.  
대신 `IS NULL` 또는 `IS NOT NULL`을 사용해야 합니다.

- `IS NULL`은 `=`(등호) 조건과 동일하게 인덱스를 사용할 수 있습니다.
- `IS NOT NULL`은 `!=`(부등호)와 같은 방식으로 인덱스를 사용할 수 없어 성능 최적화가 필요합니다.

<br>

### 패턴 매칭 (`LIKE`)

`LIKE` 연산자는 내부적으로 범위 조건(`>=` 및 `<`)으로 변환됩니다.  
와일드카드(`%`)가 문자열의 **앞부분**에 위치하면 인덱스를 사용할 수 없습니다.  
따라서, 패턴 검색 컬럼은 항상 등호(`=`) 조건이 적용된 컬럼 다음에 와야 합니다.  

<br>

### 정렬 (`ORDER BY`)

인덱스를 적절히 활용하면 정렬을 추가적으로 수행하지 않아도 됩니다.
조건부 컬럼을 먼저 인덱싱하고 정렬하는 컬럼을 나중에 추가하면 인덱스 자체가 정렬된 상태로 검색됩니다.
정렬이 필요하면 모든 결과를 메모리에 올린 후 정렬하는데, 메모리가 부족하면 **디스크를 사용**하여 속도가 급격히 저하됩니다.  

- MySQL에서는 `sort_buffer_size`, PostgreSQL에서는 `work_mem` 설정을 조정하여 정렬 성능을 향상시킬 수 있습니다.  

<br>

### 값 집계 (`DISTINCT` 및 `GROUP BY`)

`GROUP BY`와 `DISTINCT`는 내부적으로 동일한 방식으로 실행됩니다.  
따라서 `GROUP BY` 최적화 원칙이 `DISTINCT`에도 적용됩니다.  

- `GROUP BY` 컬럼을 순서대로 정렬된 인덱스를 사용하면, 루프를 돌면서 단순히 그룹을 확인하고 집계할 수 있습니다.  
- 여러 컬럼으로 그룹핑하는 경우, 해당 컬럼 순서와 동일한 인덱스를 생성해야 합니다.  
- **`WHERE` 조건이 있을 경우** SQL 실행 순서에 따라 `WHERE` 조건 컬럼이 `GROUP BY` 컬럼보다 **먼저 인덱스에 포함**되어야 합니다.  
- 범위 조건이 포함되면 `GROUP BY` 순서가 깨질 수 있습니다.
- 집계 함수(`AVG`, `SUM` 등)를 사용할 경우, **해당 컬럼까지 포함된 인덱스**를 생성하면 성능이 향상됩니다.
